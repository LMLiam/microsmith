package me.liam.microsmith.gen.schemas.protobuf

import com.github.eventhorizonlab.spi.ServiceProvider
import me.liam.microsmith.dsl.schemas.protobuf.ProtobufSchema
import me.liam.microsmith.dsl.schemas.protobuf.field.Cardinality
import me.liam.microsmith.dsl.schemas.protobuf.field.CardinalityField
import me.liam.microsmith.dsl.schemas.protobuf.field.Field
import me.liam.microsmith.dsl.schemas.protobuf.field.MapField
import me.liam.microsmith.dsl.schemas.protobuf.field.Reference
import me.liam.microsmith.dsl.schemas.protobuf.field.ReferenceField
import me.liam.microsmith.dsl.schemas.protobuf.field.ScalarField
import me.liam.microsmith.dsl.schemas.protobuf.reserved.Reserved
import me.liam.microsmith.dsl.schemas.protobuf.reserved.ReservedIndex
import me.liam.microsmith.dsl.schemas.protobuf.reserved.ReservedName
import me.liam.microsmith.dsl.schemas.protobuf.reserved.ReservedRange
import me.liam.microsmith.dsl.schemas.protobuf.reserved.ReservedToMax
import me.liam.microsmith.dsl.schemas.protobuf.types.Enum
import me.liam.microsmith.dsl.schemas.protobuf.types.Message
import me.liam.microsmith.dsl.schemas.protobuf.types.Type
import me.liam.microsmith.gen.files.FileSpace
import me.liam.microsmith.gen.files.GeneratedFile
import me.liam.microsmith.gen.schemas.SchemaEmitter
import kotlin.io.path.Path
import kotlin.reflect.KClass

@ServiceProvider(SchemaEmitter::class)
class ProtobufEmitter(
    override val type: KClass<ProtobufSchema> = ProtobufSchema::class
) : SchemaEmitter<ProtobufSchema> {
    override suspend fun ProtobufSchema.emit(space: FileSpace) =
        when (val schema = this.schema) {
            is Message -> this to schema.emit(this.name)
            is Enum -> this to schema.emit(this.name)
        }.let {
            GeneratedFile(
                Path("proto/" + it.first.name.replace(".", "/") + ".proto"),
                it.second
            )
        }

    private fun Message.emit(fqName: String): ByteArray =
        buildString {
            appendLine("// Generated by Microsmith")
            appendLine("""syntax = "proto3";""")

            fqName
                .substringBeforeLast(".")
                .takeIf { it.isNotEmpty() }
                ?.let { appendLine("package $it;") }

            val imports = collectImports()
            if (imports.isNotEmpty()) {
                imports.forEach { appendLine("""import "${it.replace(".", "/")}.proto";""") }
            }

            appendLine(renderMessage())
        }.toByteArray()

    private fun Message.renderMessage(): String =
        buildString {
            appendLine("message $name {")
            if (fields.isEmpty() && oneofs.isEmpty() && reserved.isEmpty()) {
                append("}")
                return@buildString
            }

            reservedSection()?.let { appendLine(it.prependIndent(INDENT)) }
            fieldsSection()?.forEach { appendLine(it.prependIndent(INDENT)) }
            oneofsSection()?.forEach { appendLine(it.prependIndent(INDENT)) }

            append("}")
        }

    private fun Reserved.renderReserved(): String =
        when (this) {
            is ReservedIndex -> index.toString()
            is ReservedRange -> "${indexRange.first} to ${indexRange.last}"
            is ReservedToMax -> "$from to max"
            else -> error("Unknown reserved type: ${this::class.simpleName}")
        }

    private fun Message.fieldsSection(): List<String>? = fields.takeIf { it.isNotEmpty() }?.map { it.renderField() }

    private fun Field.renderField(): String =
        buildString {
            if (this@renderField is CardinalityField && cardinality != Cardinality.REQUIRED) {
                append(
                    when (cardinality) {
                        Cardinality.OPTIONAL -> "optional "
                        Cardinality.REPEATED -> "repeated "
                        else -> error("Unknown cardinality: $cardinality")
                    }
                )
            }
            when (this@renderField) {
                is ScalarField -> append("${primitive::class.simpleName?.lowercase()} $name = $index;")
                is ReferenceField -> append("${reference.name} $name = $index;")
                is MapField -> {
                    val key =
                        type.key::class.simpleName?.lowercase()
                            ?: error("Unknown key type: ${type.key}")
                    val value =
                        when (val v = type.value) {
                            is Reference -> v.name
                            else ->
                                v::class.simpleName?.lowercase()
                                    ?: error("Unknown value type: ${type.value}")
                        }
                    append("map<$key, $value> $name = $index;")
                }
                else -> error("Unknown field type: ${this@renderField::class.simpleName}")
            }
        }

    private fun Message.oneofsSection(): List<String>? =
        oneofs.takeIf { it.isNotEmpty() }?.map { oneof ->
            buildString {
                appendLine("oneof ${oneof.name} {")
                oneof.fields.forEach { field ->
                    val type =
                        when (val ft = field.fieldType) {
                            is Reference -> ft.name
                            else ->
                                ft::class.simpleName?.lowercase()
                                    ?: error("Unknown field type: ${ft::class.simpleName}")
                        }
                    appendLine("$type ${field.name} = ${field.index};".prependIndent(INDENT))
                }
                append("}")
            }
        }

    private fun Message.collectImports(): Set<String> =
        buildSet {
            fields.forEach {
                when (it) {
                    is ReferenceField -> add(it.reference.name)
                    is MapField -> if (it.type.value is Reference) add((it.type.value as Reference).name)
                    else -> {}
                }
            }
            oneofs
                .flatMap { it.fields }
                .mapNotNull { (it.fieldType as? Reference)?.name }
                .forEach { add(it) }
        }

    private fun Enum.emit(fqName: String): ByteArray =
        buildString {
            appendLine("// Generated by Microsmith")
            appendLine("""syntax = "proto3";""")

            fqName
                .substringBeforeLast(".")
                .takeIf { it.isNotEmpty() }
                ?.let { appendLine("package $it;") }

            appendLine(renderEnum())
        }.toByteArray()

    private fun Enum.renderEnum(): String =
        buildString {
            appendLine("enum $name {")
            reservedSection()?.let { appendLine(it.prependIndent(INDENT)) }
            values.forEach { v ->
                appendLine("${v.name} = ${v.index};".prependIndent(INDENT))
            }
            append("}")
        }

    private fun Type.reservedSection(): String? {
        val reserved =
            when (this) {
                is Message -> this.reserved
                is Enum -> this.reserved
            }
        if (reserved.isEmpty()) return null

        val names =
            reserved
                .filterIsInstance<ReservedName>()
                .takeIf { it.isNotEmpty() }
                ?.joinToString(", ") { "\"${it.name}\"" }
                ?.let { "reserved $it;" }

        val indexes =
            reserved
                .filterNot { it is ReservedName }
                .takeIf { it.isNotEmpty() }
                ?.joinToString(", ") { it.renderReserved() }
                ?.let { "reserved $it;" }

        return listOfNotNull(names, indexes).joinToString("\n")
    }

    companion object {
        private const val INDENT = "  "
    }
}