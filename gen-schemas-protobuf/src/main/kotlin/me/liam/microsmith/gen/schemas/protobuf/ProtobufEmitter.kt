package me.liam.microsmith.gen.schemas.protobuf

import com.github.eventhorizonlab.spi.ServiceProvider
import me.liam.microsmith.dsl.schemas.protobuf.ProtobufSchema
import me.liam.microsmith.dsl.schemas.protobuf.field.Cardinality
import me.liam.microsmith.dsl.schemas.protobuf.field.CardinalityField
import me.liam.microsmith.dsl.schemas.protobuf.field.MapField
import me.liam.microsmith.dsl.schemas.protobuf.field.Reference
import me.liam.microsmith.dsl.schemas.protobuf.field.ReferenceField
import me.liam.microsmith.dsl.schemas.protobuf.field.ScalarField
import me.liam.microsmith.dsl.schemas.protobuf.reserved.ReservedIndex
import me.liam.microsmith.dsl.schemas.protobuf.reserved.ReservedName
import me.liam.microsmith.dsl.schemas.protobuf.reserved.ReservedRange
import me.liam.microsmith.dsl.schemas.protobuf.reserved.ReservedToMax
import me.liam.microsmith.dsl.schemas.protobuf.types.Enum
import me.liam.microsmith.dsl.schemas.protobuf.types.Message
import me.liam.microsmith.gen.files.FileSpace
import me.liam.microsmith.gen.files.GeneratedFile
import me.liam.microsmith.gen.schemas.SchemaEmitter
import me.liam.microsmith.gen.schemas.protobuf.helpers.plusAssign
import kotlin.io.path.Path
import kotlin.reflect.KClass

@ServiceProvider(SchemaEmitter::class)
class ProtobufEmitter(
    override val type: KClass<ProtobufSchema> = ProtobufSchema::class
) : SchemaEmitter<ProtobufSchema> {
    override suspend fun ProtobufSchema.emit(space: FileSpace) =
        when (val schema = this.schema) {
            is Message -> this to schema.emit(this.name)
            is Enum -> this to schema.emit(this.name)
        }.let {
            GeneratedFile(
                Path("proto/" + it.first.name.replace(".", "/") + ".proto"),
                it.second
            )
        }

    private fun Message.emit(fqName: String): ByteArray {
        val contentsBuilder = StringBuilder()

        contentsBuilder += "// Generated by Microsmith\n"

        contentsBuilder +=
            """
            syntax = "proto3";
            """.trimIndent()
        contentsBuilder += "\n"

        if (fqName.contains(".")) {
            val pkg =
                """
                package ${fqName.substringBeforeLast(".")};
                """.trimIndent()
            contentsBuilder += pkg
            contentsBuilder += "\n"
        }

        val messageBuilder = StringBuilder()
        messageBuilder += "message $name {"
        if (this.fields.isEmpty() && this.oneofs.isEmpty() && this.reserved.isEmpty()) {
            messageBuilder += "}"
            contentsBuilder += messageBuilder.toString()
            return contentsBuilder.toString().toByteArray()
        }

        if (this.reserved.isNotEmpty()) {
            val names = this.reserved.filterIsInstance<ReservedName>()
            if (names.isNotEmpty()) {
                val nameBuilder = StringBuilder()
                nameBuilder += "reserved "
                names.forEachIndexed { index, name ->
                    nameBuilder += "\"$name\""
                    if (index < names.size - 1) {
                        nameBuilder += ", "
                    }
                }
                nameBuilder += ";"
                messageBuilder += "\n" + nameBuilder.toString().prependIndent(INDENT)
            }

            val indexes = this.reserved.filter { it !is ReservedName }
            if (indexes.isNotEmpty()) {
                val indexBuilder = StringBuilder()
                indexBuilder += "reserved "
                indexes.forEachIndexed { index, reserved ->
                    indexBuilder +=
                        when (reserved) {
                            is ReservedIndex -> "${reserved.index}"
                            is ReservedRange -> "${reserved.indexRange.first} to ${reserved.indexRange.last}"
                            is ReservedToMax -> "${reserved.from} to max"
                            else -> error("Unknown reserved index type: ${reserved::class.simpleName}")
                        }
                    if (index < indexes.size - 1) {
                        indexBuilder += ", "
                    }
                }
                indexBuilder += ";"
                messageBuilder += "\n" + indexBuilder.toString().prependIndent(INDENT)
            }
        }

        val imports = mutableSetOf<String>()

        for (field in this.fields) {
            val fb = StringBuilder()
            if (field is CardinalityField && field.cardinality != Cardinality.REQUIRED) {
                fb +=
                    when (field.cardinality) {
                        Cardinality.OPTIONAL -> "optional "
                        Cardinality.REPEATED -> "repeated "
                        else -> error("Unknown cardinality: ${field.cardinality}")
                    }
            }
            when (field) {
                is ScalarField -> {
                    fb +=
                        field.primitive::class.simpleName?.lowercase() ?: error("Unknown primitive: ${field.primitive}")
                    fb += " ${field.name} = ${field.index};"
                }
                is ReferenceField -> {
                    imports += field.reference.name
                    fb += "${field.reference.name} ${field.name} = ${field.index};"
                }
                is MapField -> {
                    val key =
                        field.type.key::class.simpleName?.lowercase() ?: error("Unknown key type: ${field.type.key}")
                    fb += "map<$key, "
                    val value =
                        when (val value = field.type.value) {
                            is Reference -> value.name.also { imports += it }
                            else ->
                                value::class.simpleName?.lowercase()
                                    ?: error("Unknown value type: ${field.type.value}")
                        }
                    fb += "$value> ${field.name} = ${field.index};"
                }
                else -> error("Unknown field type: ${field::class.simpleName}")
            }
            messageBuilder += "\n" + fb.toString().prependIndent(INDENT)
        }

        for (oneof in oneofs) {
            val oneofBuilder = StringBuilder()
            oneofBuilder += "oneof ${oneof.name} {"
            for (field in oneof.fields) {
                val fb =
                    when (val ft = field.fieldType) {
                        is Reference -> {
                            imports += ft.name
                            "${ft.name} ${field.name} = ${field.index};"
                        }
                        else -> {
                            val type =
                                ft::class.simpleName?.lowercase()
                                    ?: error("Unknown field type: ${ft::class.simpleName}")
                            "$type ${field.name} = ${field.index};"
                        }
                    }
                oneofBuilder += "\n" + fb.prependIndent(INDENT)
            }
            oneofBuilder += "\n}"
            messageBuilder += "\n" + oneofBuilder.toString().prependIndent(INDENT)
        }

        messageBuilder += "\n}"
        contentsBuilder += imports.joinToString("\n") { "import \"${it.replace(".", "/")}.proto\";" }
        contentsBuilder += "\n" + messageBuilder.toString()

        return contentsBuilder.toString().toByteArray()
    }

    private fun Enum.emit(fqName: String): ByteArray = ByteArray(0)

    companion object {
        private const val INDENT = "  "
    }
}